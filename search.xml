<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我的摄影集</title>
      <link href="/cazy111.github.io/2022/04/18/%E6%91%84%E5%BD%B1%E9%9B%86/"/>
      <url>/cazy111.github.io/2022/04/18/%E6%91%84%E5%BD%B1%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\cazy111.github.io\assets\css\APlayer.min.css"><script src="\cazy111.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="摄影集"><a href="#摄影集" class="headerlink" title="摄影集"></a>摄影集</h1><h2 id="光影中的公大"><a href="#光影中的公大" class="headerlink" title="光影中的公大"></a>光影中的公大</h2><p><img src="https://cazy111.oss-cn-beijing.aliyuncs.com/%E7%9B%B8%E5%86%8C/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220418164421.jpg"><br><img src="https://cazy111.oss-cn-beijing.aliyuncs.com/%E7%9B%B8%E5%86%8C/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202204181644211.jpg"><br><img src="https://cazy111.oss-cn-beijing.aliyuncs.com/%E7%9B%B8%E5%86%8C/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202204181644212.jpg"><br><img src="https://cazy111.oss-cn-beijing.aliyuncs.com/%E7%9B%B8%E5%86%8C/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220418164609.jpg"><br><img src="https://cazy111.oss-cn-beijing.aliyuncs.com/%E7%9B%B8%E5%86%8C/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202204181646091.jpg"><br><img src="https://cazy111.oss-cn-beijing.aliyuncs.com/%E7%9B%B8%E5%86%8C/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202204181646092.jpg"><br><img src="https://cazy111.oss-cn-beijing.aliyuncs.com/%E7%9B%B8%E5%86%8C/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202204181646093.jpg"><br><img src="https://cazy111.oss-cn-beijing.aliyuncs.com/%E7%9B%B8%E5%86%8C/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202204181646094.jpg"><br><img src="https://cazy111.oss-cn-beijing.aliyuncs.com/%E7%9B%B8%E5%86%8C/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202204181646095.jpg"><br><img src="https://cazy111.oss-cn-beijing.aliyuncs.com/%E7%9B%B8%E5%86%8C/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202204181646096.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法竞赛入门经典</title>
      <link href="/cazy111.github.io/2022/04/02/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/"/>
      <url>/cazy111.github.io/2022/04/02/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\cazy111.github.io\assets\css\APlayer.min.css"><script src="\cazy111.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="算法竞赛入门经典"><a href="#算法竞赛入门经典" class="headerlink" title="算法竞赛入门经典"></a>算法竞赛入门经典</h1><h2 id="第三章-数组和字符串"><a href="#第三章-数组和字符串" class="headerlink" title="第三章 数组和字符串"></a>第三章 数组和字符串</h2><h3 id="3-2-字符数组"><a href="#3-2-字符数组" class="headerlink" title="3.2 字符数组"></a>3.2 字符数组</h3><p><strong>程序3-4 竖式问题</strong><br>#include&lt;string.h&gt; 用到了string.h库的函数:<br><strong>sprintf函数</strong><br>sprintf的作用是将一个格式化的字符串输出到数组中,而printf的作用是将一个格式化的字符串输出到屏幕中。<br>sprintf(a,格式化字符串) a是目标数组,后面跟着格式化字符串<br><strong>strlen函数</strong><br>strlen的作用是计算字符串的长度<br><strong>strchr函数</strong><br>char *strchr(const char <em>s,int c)<br>如果s字符串包含c字符,该函数返回指向s字符串首次出现的c字符的指针(末尾的空字符也是字符串的一部分,所以在查找范围内)。</em><br>如果在字符串s中未找到c字符,该函数则返回空指针</p><h3 id="3-3-竞赛题目选讲"><a href="#3-3-竞赛题目选讲" class="headerlink" title="3.3 竞赛题目选讲"></a>3.3 竞赛题目选讲</h3><p><strong>例题3-1 Tex中的引号</strong><br>问题:输入的字符串中存在空格、TAB、换行符,那么使用scanf函数实现输入会导致字符串输入不完整。<br>解决方法:<br>1.<strong>fgetc(fin)</strong><br>该函数会读取一个打开的文件,读取一个字符,然后返回一个int值<br>使用该方法可以边读边处理,使用该函数加上while函数,将整个字符串拆分成单个字符,先判断后执行,之后输出整个修改过后的字符串。<br>2.<strong>fgets(buf,maxn,fin)</strong><br>该方法可以读取完整的一行<br><strong>例题3-2 WERTYU</strong></p><h2 id="第四章-函数和递归"><a href="#第四章-函数和递归" class="headerlink" title="第四章 函数和递归"></a>第四章 函数和递归</h2><h3 id="4-1-函数和结构体"><a href="#4-1-函数和结构体" class="headerlink" title="4.1 函数和结构体"></a>4.1 函数和结构体</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CTF相关学习</title>
      <link href="/cazy111.github.io/2022/02/13/CTF%E5%AD%A6%E4%B9%A0/"/>
      <url>/cazy111.github.io/2022/02/13/CTF%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\cazy111.github.io\assets\css\APlayer.min.css"><script src="\cazy111.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="1-分组密码"><a href="#1-分组密码" class="headerlink" title="1.分组密码"></a>1.分组密码</h2><p>分组加密又称为分块加密或块密码,是一种对称密码算法,这类算法将铭文分成多个等长的块,使用确定的算法和对称密钥对每组分别加密或解密。分组密码是极其重要的加密体制,如DES和AES曾作为美国政府核定的标准加密算法。<br>本质上,块加密可以理解成一种特殊的替代密码,只不过每次替代的是一大块。因为明文空间非常大,所以对于不同的密钥,无法制作一个对应明密文的密码表,只能用特定的解密算法来还原明文。</p><h3 id="1-1-分组密码常见的工作模式"><a href="#1-1-分组密码常见的工作模式" class="headerlink" title="1.1 分组密码常见的工作模式"></a>1.1 分组密码常见的工作模式</h3><p>密码学中,分组密码的工作模式允许使用同一个分组密码密钥对多于一块的数据进行加密,并保证其安全性。分组密码自身只能加密长度等于密码分组长度的单块数据,若要加密变长数据,则数据必须先被划分为一些单独的密码块。通常而言,最后一块数据需要使用合适填充方式将数据扩展到匹配密码快大小的长度。分组密码的工作模式描述了加密每个数据块的过程,并常常使用基于一个称为初始化向量的附加输入值进行随机化,以保证安全。<br>对加密模式的研究曾经包含数据的完整性保护,即在某些数据被需改后的情况下密码的误差传播特性。后来的研究则将完整性保护作为另一个完全不同的,与加密无关的密码学目标。部分现代的工作模式用有效的方法将加密和认证结合起来,称为认证加密模式。</p><h4 id="1-1-1-ECB加密"><a href="#1-1-1-ECB加密" class="headerlink" title="1.1.1.ECB加密"></a>1.1.1.ECB加密</h4><p>ECB,即电子密码本,是分组加密最简单的一种模式,即明文的每个块都独立地加密成密文的每个块。如果明文的长度不是分组长度的倍数,则需要一些特定的方法进行填充。ECB的缺点在于同样的明文块会被加密成相同的密文块,因此不能很好地隐藏数据模式。</p><h4 id="1-1-2-CBC加密"><a href="#1-1-2-CBC加密" class="headerlink" title="1.1.2 CBC加密"></a>1.1.2 CBC加密</h4><p>CBC,即密码分组链接。每个明文块先与前一个密文块进行异或后再进行加密。在这种方法中,每个密文快都依赖于它前面所有的明文块;同时,为了保证每条消息的唯一性,在第一个块中需要使用初始化向量</p><h4 id="1-2-费斯妥密码和DES"><a href="#1-2-费斯妥密码和DES" class="headerlink" title="1.2 费斯妥密码和DES"></a>1.2 费斯妥密码和DES</h4><h4 id="1-3-AES加密"><a href="#1-3-AES加密" class="headerlink" title="1.3 AES加密"></a>1.3 AES加密</h4><p>AES的加密过程是在一个4 * 4 字节大小的矩阵上运作的,这个矩阵又称为“体”,其初值是一个明文区块(矩阵中的一个元素就是明文区块中的1byte)<br>各轮AES加密循环(除最后一轮)均包含4个步骤:<br>1.<strong>AddRoundKey</strong><br>矩阵中的每字节都与该回合密钥做异或,每个子密钥由密钥生成方案产生。<br>2.<strong>SubBytes</strong><br>透过一个非线性的替换函数。用查找表的方式把每字节替换成对应字节。<br>3.<strong>ShiftRows</strong><br>将矩阵中的每个横列进行循环式移位<br>4.<strong>MixColumns</strong><br>充分混合矩阵中割裂的操作,使用线性转换混合每列的4字节。最后一个加密循环中省略本步骤,而以AddRoundKey取代。</p><h2 id="2-流密码"><a href="#2-流密码" class="headerlink" title="2.流密码"></a>2.流密码</h2><h2 id="公钥密码"><a href="#公钥密码" class="headerlink" title="公钥密码"></a>公钥密码</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记A</title>
      <link href="/cazy111.github.io/2022/02/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/cazy111.github.io/2022/02/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\cazy111.github.io\assets\css\APlayer.min.css"><script src="\cazy111.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="深入理解计算机系统"><a href="#深入理解计算机系统" class="headerlink" title="深入理解计算机系统"></a>深入理解计算机系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>此书可以帮助深入了解计算机系统是如何工作,计算机的硬件软件是如何影响程序的正确性和性能。</p><h2 id="第一章-计算机系统漫游"><a href="#第一章-计算机系统漫游" class="headerlink" title="第一章:计算机系统漫游"></a>第一章:计算机系统漫游</h2><h3 id="1-1-信息就是位-上下文"><a href="#1-1-信息就是位-上下文" class="headerlink" title="1.1 信息就是位+上下文"></a>1.1 信息就是位+上下文</h3><p>源程序是程序员通过编辑器创建并保存的文本文件。其本质是由0,1组成的位(比特)序列,8个位被组织成一组,称为字。每个字节表示程序中的某个文本字符。<br>ASCII码便是其组织方式。将文本字符通过ASCII码转换成十进制数字,再转换成八比特的二进制数字,这就改变了信息的表达方式。<br>表达方式的改变说明了一个基本思想:系统中所有的信息(磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据,都是由一串比特表示的。</p><h3 id="1-2-程序被其他程序翻译成不同的格式"><a href="#1-2-程序被其他程序翻译成不同的格式" class="headerlink" title="1.2 程序被其他程序翻译成不同的格式"></a>1.2 程序被其他程序翻译成不同的格式</h3><p>一个程序从高级C语言程序开始,因为这种形式能够被人读懂。之后就被其他程序转化成一系列的低级机器语言指令,然后这些指令按照一种称为可执行目标程序的格式打好包,并以二进制磁盘文件的形式存放起来。目标程序也称为可执行目标文件。</p><p>不同文件对应不同语言,语言的转化需要翻译,最终变成机器能够读懂的语言。比如Unix系统,从源文件到目标文件的转化是由编译器驱动程序完成的。(GCC编译器驱动程序)</p><p>GCC编译器驱动程序的翻译过程可以分为四个阶段:预处理器、编译器、汇编器、链接器。</p><p>预处理阶段:预处理器(cpp)根据以字符#开头的命令,修改原始的C程序。<br>比如#include&lt;stdio.h&gt;命令告诉预处理器读取系统头文件stdio.h的内容,并把它直接插入程序文本之中。后缀名由(.c)变成(.i)</p><p>编译阶段:编译器(ccl)将文本后缀名由(.i)变成(.s)。此时文件的表达方式是汇编语言。汇编语言非常有用,因为它为不同高级语言的不同编译器提供了通用的输出语言。</p><p>汇编阶段:汇编器(as)将文件的表达方式翻译成机器语言指令,并把这些指令打包成一种叫做可重定位目标程序,并将结果保存在目标文件(hello.o)中。</p><p>链接阶段:将预编译好了的目标文件合并到hello.o程序中,由链接器(ld)完成。比如程序调用printf函数。printf函数是预编译在stdio.o的。之后就得到了可执行目标文件,可以被加载到内存中,由系统执行。</p><h3 id="1-3-了解编译系统是如何工作是大有益处的"><a href="#1-3-了解编译系统是如何工作是大有益处的" class="headerlink" title="1.3 了解编译系统是如何工作是大有益处的"></a>1.3 了解编译系统是如何工作是大有益处的</h3><p>我们为什么需要知道编译系统是如何工作的呢?<br>1.<strong>优化程序性能</strong><br>为了在C程序中做出好的编码选择,我们需要了解一些机器代码以及编译器将不同的C语句转化为机器代码的方式。比如,一个switch语句是否总是比一系列的if-else语句高效的多?一个函数调用的开销有多大?while循比for循环更有效吗?指针引用比数组索引更有效吗?为什么将循环求和的结果放到一个本地变量中,会比将其放到一个通过引用传递过来的参数中,运行起来快很多?……<br>2.<strong>理解链接时出现的错误</strong><br>当试图构建大的软件系统时,链接器报告说它无法解析一个引用,这是什么意思?静态变量和全局变量的区别是什么?如果在不同的C文件中定义了名字相同的两个全局变量会发生什么?静态库和动态库的区别是什么?……<br>3.<strong>避免安全漏洞</strong><br>缓冲区溢出错误时造成大多数网络和Internet服务器上安全漏洞的主要原因。存在这些错误是因为很少有程序员能理解需要限制从不受新人的源接受数据的数量和格式。学习安全编程的第一步就是理解数据和程序信息存储在程序栈上的方式会引起的后果。</p><h3 id="1-4-处理器读并解释储存在内存中的指令"><a href="#1-4-处理器读并解释储存在内存中的指令" class="headerlink" title="1.4 处理器读并解释储存在内存中的指令"></a>1.4 处理器读并解释储存在内存中的指令</h3><h4 id="1-4-1系统的硬件组成"><a href="#1-4-1系统的硬件组成" class="headerlink" title="1.4.1系统的硬件组成"></a>1.4.1系统的硬件组成</h4><p>1.<strong>总线</strong><br>是指贯穿整个系统的一组电子管道,它携带信息字节并负责在各个部件之间传递。通常总线被设计成传送定长的字节块,也就是字。字中的字节数(字长)是一个基本的系统参数,各个系统中都不尽相同。现在大多都是4个字节(32位)或者是8个字节。(32位)<br>2.<strong>I&#x2F;O设备</strong><br>指in or out。I&#x2F;O设备是系统与外部世界的联系通道。一般有:键盘鼠标,显示器,磁盘。每一个I&#x2F;O设备都通过一个控制器或者适配器与I&#x2F;O总线相连。控制器和适配器之间的区别主要在于它们的封装方式。控制器是I&#x2F;O本身或者烯体哦那个的主印制电路板(通常叫做主板)上的芯片组。而适配器则是一块插在主板插槽上的卡。他们的功能都是负责在I&#x2F;O总线和I&#x2F;O设备之间传递信息。<br>3.<strong>主存</strong><br>主存是一个临时存储设备,在处理器执行程序时,用来存放程序和程序处理的数据。从物理上说,主存是由一组动态随机存取存储(DRAM)芯片组成的。从逻辑上来说,存储器是一个线性的字节数组,每个字节都有唯一的地址(数组索引)<br>4.<strong>处理器</strong><br>中央处理单元(CPU),简称处理器,即解释(或执行)存储在主存中的指令的引擎。处理器的核心是一个大小为一个字节的存储设备(或寄存器),称为程序计数器(PC)。在任何时候,PC都指向主存中的某条机器语言指令(即含有该条指令的地址)  (<strong>图灵机</strong>)<br>从系统通电开始,直到系统断电,CPU一直在不断地执行程序计数器指向的指令,再更新程序计数器,使其指向下一条指令。处理器看上去是按照一个非常简单的指令执行模型来操作的,这个模型是由指令集架构决定的。在这个模型中,指令按照严格的顺序执行,而执行一条指令包含一系列的步骤。处理器从程序计数器指向的内存储读取指令,解释指令中的位,执行该指令指示的简单操作,然后更新PC,使其指向下一条指令,二这条指令并不一定和在内存中刚刚执行的指令相邻。<br>这样的简单曹祖并不多,它们围绕着主存、寄存器文件和算术&#x2F;逻辑单元(ALU)进行。寄存器文件是一个小的存储设备,由一些单个字长的寄存器组成,每个寄存器都有唯一的名字。ALU计算新的数据和地址值。</p><h4 id="1-4-2-运行程序"><a href="#1-4-2-运行程序" class="headerlink" title="1.4.2 运行程序"></a>1.4.2 运行程序</h4><p>见书P8流程图</p><h3 id="1-5-高速缓存至关重要"><a href="#1-5-高速缓存至关重要" class="headerlink" title="1.5 高速缓存至关重要"></a>1.5 高速缓存至关重要</h3><p>由1.4.2的运行程序可以发现,系统花费了大量的时间把信息从一个地方挪到另一个地方。过多的赋值减慢的程序真正的工作。因此,系统设计者的一个主要目标就是使这些复制操作尽可能快地完成。</p><h3 id="1-6-存储设备形成层次结构"><a href="#1-6-存储设备形成层次结构" class="headerlink" title="1.6 存储设备形成层次结构"></a>1.6 存储设备形成层次结构</h3><p>层次图见书P10</p><h3 id="1-7-操作系统管理硬件"><a href="#1-7-操作系统管理硬件" class="headerlink" title="1.7 操作系统管理硬件"></a>1.7 操作系统管理硬件</h3><p>所有应用程序对硬件的操作尝试都必须通过操作系统。<br>操作系统有两个基本功能:1.防止应急爱你被失控的应用程序滥用。2.向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过进程,虚拟内存,文件这三个基本的抽象概念来实现这两个功能。文件时对I&#x2F;0设备的抽象表示,虚拟内存是对主存和磁盘I&#x2F;O设备的抽象表示,进程是对处理器、主存和I&#x2F;O设备的抽象表示。</p><h4 id="1-7-1-进程"><a href="#1-7-1-进程" class="headerlink" title="1.7.1 进程"></a>1.7.1 进程</h4><p>进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程,而每个进程都好像在独占地使用硬件。而并发运行,则是说一个进程的指令和另一个进程的指令是交错执行的。即CPU在进程间切换。操作系统实现这种交错执行的机制称为上下文切换。<br>操作系统保持跟踪进程运行所需的所有状态信息这种状态,也就是上下文,包括许多信息,比如PC和寄存器文件的当前值,以及主存的内容。在任何时刻,单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时,就会进行上下文切换,即保存当前进程的上下文、恢复新进程的上下文,然后将控制权传递到新进程。<br>从一个进程到另一个进程的转换是由操作系统内核(kernel)管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时,比如读写文件,它就执行一条特殊的系统调用指令,将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。内核不是一个独立的进程,而是系统管理全部进程所用代码和数据结构的集合。</p><h4 id="1-7-2-线程"><a href="#1-7-2-线程" class="headerlink" title="1.7.2 线程"></a>1.7.2 线程</h4><p>一个进程实际上可以由多个称为线程的执行单元组成,每个线程都运行在进程的上下文中,并共享同样的代码和全局数据。</p><h4 id="1-7-3-虚拟内存-这一块读不懂-暂时不做笔记"><a href="#1-7-3-虚拟内存-这一块读不懂-暂时不做笔记" class="headerlink" title="1.7.3 虚拟内存(这一块读不懂,暂时不做笔记)"></a>1.7.3 虚拟内存(这一块读不懂,暂时不做笔记)</h4><p>虚拟内存是一个抽象概念,它为每个进程提供了一个假象,即每个进程都在独占地使用主存。每个进程看到的内存都是一致的,称为虚拟地址空间。而每个进程看到的虚拟地址空间由大量准确定义的区构成,每个区都有专门的功能。<br>1.<strong>程序代码和数据</strong></p><h4 id="1-7-4-文件"><a href="#1-7-4-文件" class="headerlink" title="1.7.4 文件"></a>1.7.4 文件</h4><p>文件就是字节序列,仅此而已。每个I&#x2F;O设备都可以看成文件。系统中所有的输入输出都是通过使用一小组称为Unix I&#x2F;O的系统函数调用读写文件来实现的。<br>文件这个概念简单而精致,它向应用程序提供了一个统一的视图,来看待系统中可能含有的所有各式各样的I&#x2F;O设备。</p><h4 id="1-8-系统之间利用网络通信"><a href="#1-8-系统之间利用网络通信" class="headerlink" title="1.8 系统之间利用网络通信"></a>1.8 系统之间利用网络通信</h4><p>从单独的系统来看,网络可视为一个I&#x2F;O设备。例子见书P15.</p><p>(剩下两小节暂时看不懂,不做读书笔记,之后补)</p><h2 id="第二章-信息的表示和处理"><a href="#第二章-信息的表示和处理" class="headerlink" title="第二章 信息的表示和处理"></a>第二章 信息的表示和处理</h2><h3 id="2-1-信息存储"><a href="#2-1-信息存储" class="headerlink" title="2.1 信息存储"></a>2.1 信息存储</h3><p>大多数计算机使用8位的块,即字节(byte),作为最小的可寻址的内存单位,而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组,称为虚拟内存。内存的每个字节都由一个唯一的数字来标识,称为它的地址,所有可能地址的集合就成为虚拟地址空间。这个虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现是将动态随机访问存储器、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来,为程序提供一个看上去统一的字节数组。</p><h4 id="2-1-1-十六进制表示法"><a href="#2-1-1-十六进制表示法" class="headerlink" title="2.1.1 十六进制表示法"></a>2.1.1 十六进制表示法</h4><h4 id="2-1-2-字数据大小"><a href="#2-1-2-字数据大小" class="headerlink" title="2.1.2 字数据大小"></a>2.1.2 字数据大小</h4><p>每台计算机都有一个字长,指明指针数据的标称大小。因为虚拟地址是以这样的一个字来编码的,所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。<br>大多数64位机器可以运行32位机器编译的程序,这是一种向后兼容。<br>使用确定大小的整数类型是程序员准确控制数据表示的最佳途径。<br>程序员应该力图使他们的程序在不同的机器和编译器上可移植。可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感。</p><h4 id="2-1-3-寻址和字节顺序"><a href="#2-1-3-寻址和字节顺序" class="headerlink" title="2.1.3 寻址和字节顺序"></a>2.1.3 寻址和字节顺序</h4><p>对于跨越多字节的程序对象,必须建立两个规则:这个对象的地址是什么,以及在内存中如何排列这些字节。在几乎所有的机器上,多字节对象都被存储为连续的字节序列,对象的地址为所使用字节中最小的地址。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Crypto刷题</title>
      <link href="/cazy111.github.io/2022/02/12/Crypto%E5%88%B7%E9%A2%98/"/>
      <url>/cazy111.github.io/2022/02/12/Crypto%E5%88%B7%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\cazy111.github.io\assets\css\APlayer.min.css"><script src="\cazy111.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="2022-1-长安杯"><a href="#2022-1-长安杯" class="headerlink" title="2022.1 长安杯"></a>2022.1 长安杯</h1><p>复盘网址:<a href="http://www.yunyansec.com/">www.yunyansec.com</a></p><h2 id="1-no-cry-no-can-分组密码ECB"><a href="#1-no-cry-no-can-分组密码ECB" class="headerlink" title="1.no cry no can (分组密码ECB)"></a>1.no cry no can (分组密码ECB)</h2><p><strong>题目</strong>:<br>len(key) &lt;&#x3D; 5<br>flag[:5] &#x3D;&#x3D; b’cazy{‘<br>def can_encrypt(flag,key):<br>    block_len &#x3D; len(flag) &#x2F;&#x2F; len(key) + 1<br>    new_key &#x3D; key * block_len<br>    return bytes([i^j for i,j in zip(flag,new_key)])</p><p>c &#x3D; can_encrypt(flag,key)<br>print(c)</p><p>结果b’&lt;pH\x86\x1a&amp;”m\xce\x12\x00pm\x97U1uA\xcf\x0c:NP\xcf\x18~l’</p><p><strong>解答</strong>:<br>已知flag前五个元素是cazy{  密钥和cazy{分别异或得到结果是&lt; p H \x86 \x1a。利用这五个结果和cazy{异或得到密钥为<br>[95, 17, 50, 255, 97],用字节表示就是b’_\x112\xffa’<br>再利用密钥和密文进行异或得到明文b’cazy{y3_1s_a_h4nds0me_b0y!}’</p><p><strong>总结</strong>:<br>1.<strong>异或</strong><br>a与b异或 得到c c记录的是a和b之间相同部分的信息<br>a与c异或得到b 这三个量 知二可求一<br>2.<strong>ECB</strong><br>分组加密</p><h2 id="2-no-can-no-bb-分组密码AES"><a href="#2-no-can-no-bb-分组密码AES" class="headerlink" title="2.no can no bb (分组密码AES)"></a>2.no can no bb (分组密码AES)</h2><p><strong>题目</strong>:<br>import random<br>from Crypto.Util.number import long_to_bytes<br>from Crypto.Cipher import AES<br>from secret import flag</p><p>flag[:5] &#x3D;&#x3D;b’cazy{‘</p><p>def pad(m):<br>    tmp &#x3D; 16-(len(m)%16)<br>    return m + bytes([tmp for _ in range(tmp)])</p><p>def encrypt(m,key):<br>    aes &#x3D; AES.new(key,AES.MODE_ECB)<br>    return aes.encrypt(m)</p><p>if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“:<br>    flag &#x3D; pad(flag)<br>    key &#x3D; pad(long_to_bytes(random.randrange(1,1&lt;&lt;20)))<br>    c &#x3D; encrypt(flag,key)<br>    print(c)<br>c &#x3D; b’\x9d\x18K\x84n\xb8b|\x18\xad4\xc6\xfc\xec\xfe\x14\x0b_T\xe3\x1b\x03Q\x96e\x9e\xb8MQ\xd5\xc3\x1c’</p><p><strong>解答</strong><br>从提示中能看出是AES加密。</p><h2 id="3-no-math-no-cry"><a href="#3-no-math-no-cry" class="headerlink" title="3.no math no cry"></a>3.no math no cry</h2><p><strong>题目</strong><br>from Crypto.Util.number import*<br>from secret import flag</p><p>assert len(flag) &lt;&#x3D; 80<br>def sec_encry(m):<br>    cip &#x3D; (m - (1&lt;&lt;500))**2 + 0x0338470<br>    return cip</p><p>if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“:<br>    m &#x3D; bytes_to_long(flag)<br>    c &#x3D; sec_encry(m)<br>    print(c)</p><p>c&#x3D;10715086071862673209484250490600018105614048117055336074437503883703510511248211671489145400471130049712947188505612184220711949974689275316345656079538583389095869818942817127245278601695124271626668045250476877726638182396614587807925457735428719972874944279172128411500209111406507112585996098530169</p><p><strong>分析</strong><br>实际上是送分题。对sec_encry逆运算就可以。但是逆运算的时候需要注意开根的时候要用gmpy2库的iroot函数。<br>gmpy2.root(a,2)<br>不要用math sqrt开根号,会出问题,虽然我也不知道为什么。</p><p><strong>总结</strong><br>1.<strong>转码</strong><br>bytes_to_long函数,将字节转成整型(long)<br>long_to_bytes函数,将整型(long)转成字节<br>2.<strong>gmpy2库的使用</strong><br>gmpy2.iroot()</p><h1 id="攻防世界"><a href="#攻防世界" class="headerlink" title="攻防世界"></a>攻防世界</h1><h2 id="新手村"><a href="#新手村" class="headerlink" title="新手村"></a>新手村</h2><h3 id="9-easychallenge"><a href="#9-easychallenge" class="headerlink" title="9.easychallenge"></a>9.easychallenge</h3><p>下载附件,得到文件后缀名是pyc,进行反编译。<br>这边进行反编译的时候,整的我血压上来了。本来是使用uncompyle6库,uncompyle6似乎是不兼容python3.10,这边卡了我好久,最后选择在线反编译,只能说真香,一下就出来了。附上网址<a href="https://tool.lu/pyc/">https://tool.lu/pyc/</a> 这个网站还有很多其他功能,还是很香的。<br>反编译之后终于拿到py文件,打开得到:<br>import base64<br>final &#x3D; ‘UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E&#x3D;&#x3D;&#x3D;’<br>def decode3(final):<br>    a &#x3D; base64.b32decode(final)<br>    return a.decode(‘ISO-8859-1’)<br>def decode2(final):<br>    s &#x3D; ‘’<br>    for i in final:<br>        x &#x3D; ord(i) ^ 36<br>        x &#x3D; x - 36<br>        s +&#x3D; chr(x)<br>    return s<br>def decode1(final):<br>    s &#x3D; ‘’<br>    for i in final:<br>        x &#x3D; ord(i) - 25<br>        x &#x3D; x ^ 36<br>        s +&#x3D; chr(x)<br>    return s<br>print(decode1(decode2(decode3(final))))<br>定义了三个加密函数,那就一层一层拨开就可以了,思路很简单,开始写程序。<br>但是程序运行时遇到一些问题,将final b32解码之后得到的时字节形式的数据,但是将字节转换成字符串的时候遇到问题 utf-8字符集解码不出来。解码得到的数据都是用十六进制表示的,说明不在ascii码中,很麻烦。最后发现是ISO-8859-1解码。<br>所以flag是cyberpeace{interestinghhhhh}</p><p><strong>总结</strong><br>1.<strong>反编译</strong><br>学到在线反编译pyc文件<br>2.<strong>base64解码</strong><br>如何使用base64库解码得到字符串</p><h3 id="10-轮转机加密"><a href="#10-轮转机加密" class="headerlink" title="10.轮转机加密"></a>10.轮转机加密</h3><p>没听说过,所以上网查咯。发现没有现成的在线工具,只好学一下原理,然后自己写个脚本咯。<br>1:  &lt; ZWAXJGDLUBVIQHKYPNTCRMOSFE &lt;<br>2:  &lt; KPBELNACZDTRXMJQOYHGVSFUWI &lt;<br>3:  &lt; BDMAIZVRNSJUWFHTEQGYXPLOCK &lt;<br>4:  &lt; RPLNDVHGFCUKTEBSXQYIZMJWAO &lt;<br>5:  &lt; IHFRLABEUOTSGJVDKCPMNZQWXY &lt;<br>6:  &lt; AMKGHIWPNYCJBFZDRUSLOQXVET &lt;<br>7:  &lt; GWTHSPYBXIZULVKMRAFDCEONJQ &lt;<br>8:  &lt; NOZUTWDCVRJLXKISEFAPMYGHBQ &lt;<br>9:  &lt; XPLTDSRFHENYVUBMCQWAOIKZGJ &lt;<br>10: &lt; UDNAJFBOWTGVRSCZQKELMXYIHP &lt;<br>11: &lt; MNBVCXZQWERTPOIUYALSKDJFHG &lt;<br>12: &lt; LVNCMXZPQOWEIURYTASBKJDFHG &lt;<br>13: &lt; JZQAWSXCDERFVBGTYHNUMKILOP &lt;</p><p>密钥为:2,3,7,5,13,12,9,1,8,10,4,11,6<br>密文为:NFQKSEVOQOFNP<br>从提示轮转机加密可以猜到应该是某种映射,映射的方法应该就藏在表中。<br><strong>过程</strong><br>首先对表重组<br>第一行填写第二行,第二行填写第三行,依次对应。<br>然后再轮转,将密文放在同一列,观察其他列,得到有意义的信息 fireinthehole<br><strong>总结</strong><br>古典密码在设计上比较巧妙,需要靠分析猜测。多分析所给条件的隐藏信息。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记B</title>
      <link href="/cazy111.github.io/2022/02/12/%E6%98%8E%E6%9C%9D%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
      <url>/cazy111.github.io/2022/02/12/%E6%98%8E%E6%9C%9D%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\cazy111.github.io\assets\css\APlayer.min.css"><script src="\cazy111.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="明朝那些事儿-第一部-洪武大帝"><a href="#明朝那些事儿-第一部-洪武大帝" class="headerlink" title="明朝那些事儿 第一部 洪武大帝"></a>明朝那些事儿 第一部 洪武大帝</h1><h2 id="第十四章-复仇"><a href="#第十四章-复仇" class="headerlink" title="第十四章 复仇"></a>第十四章 复仇</h2><h3 id="1-元朝的介绍"><a href="#1-元朝的介绍" class="headerlink" title="1.元朝的介绍"></a>1.元朝的介绍</h3><p>元是蒙古建立的政权。蒙古强大开始于十二世纪,1206年,蒙古族首领铁木真统一漠北,代表着蒙古进入全盛时期。蒙古人本身战斗力很强,他们是天生的战士,但作者认为蒙古族之所以一直没有登上历史舞台,只是因为自身的分裂。而铁木真解决了这个问题,因而蒙古族开始强盛。<br>蒙古的作战制度简单实用,没有南宋那些无用的官僚机构。作战时采用小股骑兵试探,然后采用突然袭击的饿方法对地方薄弱部位实施冲击。一旦攻击受挫,立即撤走,然后寻机从侧面突破。<br>机动,是蒙古军队的最大优点。<br>蒙古的武器:弓,射程可达300米,无论多厚的铠甲都难以抵挡。蒙古骑兵的通过弓箭,利用攻击距离的优势进行游击,拉扯。这就是为什么蒙古军队进攻东欧时,那些体格远远比他们健壮的欧洲人被打的落花流水的原因。<br>蒙古还有一个特点:屠城。他们的屠城带有政治色彩:是为了让对手屈服。他们认为,有人在自己身后是不安全的。<br>欧洲人似乎更有自律精神,认为时自己犯错太多,上帝用鞭子教训自己,所以他们称蒙古人为“上帝之鞭”。这一荣誉称号的授予在欧洲历史上是第二次,第一次是给了匈奴王阿提拉。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记</title>
      <link href="/cazy111.github.io/2022/02/12/Python/"/>
      <url>/cazy111.github.io/2022/02/12/Python/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\cazy111.github.io\assets\css\APlayer.min.css"><script src="\cazy111.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="第一部分-数据结构"><a href="#第一部分-数据结构" class="headerlink" title="第一部分 数据结构"></a>第一部分 数据结构</h2><h3 id="1-1-字符串"><a href="#1-1-字符串" class="headerlink" title="1.1 字符串"></a>1.1 字符串</h3><p>字符串的本质是字符序列。在Python中字符串是不可变的。Python也不支持单字符类型,单字符也是作为一个字符串使用。</p><h4 id="1-1-1-字符串的编码"><a href="#1-1-1-字符串的编码" class="headerlink" title="1.1.1 字符串的编码"></a>1.1.1 字符串的编码</h4><p>Python3直接支持Unicode,默认使用16位Unicode编码,即2的16次方,ASCII码是Unicode编码的子集。编码的作用就是将数组和符号对应起来。<br>内置函数ord(‘str’)可以把字符串转换成对应的Unicode码<br>内置函数chr()可以把十进制数字转换成对应的字符</p><h4 id="1-1-2-特殊字符串"><a href="#1-1-2-特殊字符串" class="headerlink" title="1.1.2 特殊字符串"></a>1.1.2 特殊字符串</h4><p>1.<strong>空字符串</strong><br>Python允许空字符串的存在,不包含任何字符<br>2.<strong>转义字符</strong><br>+特殊字符 可以将字符的含义转变<br>(在行尾时)   :续行符<br>\          :反斜杠符号<br>&#39;          :单引号<br>\“         :双引号<br>\b          :退格<br>\n          :换行<br>\t          :横向制表符<br>\r          :回车</p><h4 id="1-1-3-字符串的创建"><a href="#1-1-3-字符串的创建" class="headerlink" title="1.1.3 字符串的创建"></a>1.1.3 字符串的创建</h4><p>可以通过单引号或者双引号创建字符串,使用两种引号可以避免使用转义字符。<br>连续三个单引号或者双引号,可以创建多行字符串,可以避免使用换行符</p><h4 id="1-1-4-字符串长度"><a href="#1-1-4-字符串长度" class="headerlink" title="1.1.4 字符串长度"></a>1.1.4 字符串长度</h4><p>使用len(“str”)可以得到字符串长度。</p><h4 id="1-1-5-字符串的拼接"><a href="#1-1-5-字符串的拼接" class="headerlink" title="1.1.5 字符串的拼接"></a>1.1.5 字符串的拼接</h4><p>使用字符串拼接符+,会生成新的字符串对象,每操作一个+就会生成一个新的字符串对象,因此不推荐使用+拼接字符串,推荐使用join()函数,因为join()函数在拼接字符串之前会计算所有字符串的长度,然后逐一拷贝,仅新建一次对象。<br>1.<strong>利用加号</strong><br>“aa”+”bb” &#x3D;&#x3D;”aabb”<br>2.<strong>直接放在一起</strong><br>“aa””bb” &#x3D;&#x3D; “aabb”<br>3.**利用join()合并 1.1.9.4互补</p><h4 id="1-1-6-字符串的复制"><a href="#1-1-6-字符串的复制" class="headerlink" title="1.1.6 字符串的复制"></a>1.1.6 字符串的复制</h4><p>利用*<br>“str”*3 &#x3D;&#x3D; “strstrstr”</p><h4 id="1-1-7-字符串的打印"><a href="#1-1-7-字符串的打印" class="headerlink" title="1.1.7 字符串的打印"></a>1.1.7 字符串的打印</h4><p>利用print()函数<br><strong>不换行打印</strong><br>print函数默认状态是print(str,end&#x3D;”\n”)<br>所以只需改成print(“aa”,end&#x3D;””)</p><h4 id="1-1-8-字符串的获取"><a href="#1-1-8-字符串的获取" class="headerlink" title="1.1.8 字符串的获取"></a>1.1.8 字符串的获取</h4><p> 1.<strong>input函数</strong><br> input函数可以从控制台读取键盘输入的内容<br> input(“此处为输入前的提示内容”)<br> 2.<strong>数据类型转换成字符串</strong><br> 利用str()函数可以把自他数据类型转换成字符串<br> 而在print()函数中,解释器自动调用了str()将非字符串对象转成了字符串。<br> ‘a’.join(b)其中字符a是指定连接符,b为被处理字符串</p><h4 id="1-1-9-字符串内部的处理"><a href="#1-1-9-字符串内部的处理" class="headerlink" title="1.1.9 字符串内部的处理"></a>1.1.9 字符串内部的处理</h4><p> 1.<strong>使用[]提取字符</strong><br> 字符串的本质是字符序列,可以通过在字符串后面添加[],在[]里面指定偏移量,就可以提取该位置的单个字符。<br> 正向搜索:最左侧第一个字符,偏移量是0,第二个偏移量是1,以此类推。直到len(str)-1为止。<br> 反向搜索:最右侧第一个字符,偏移量是-1,倒数第二个偏移量是-2,直到-len(str)为止。<br> 2.<strong>字符串的替换</strong><br> replace()实现字符串的变换<br> 字符串不可改变,但可以通过创建新的字符串来实现<br> str.replace(“a”,”b”)的含义是将字符串str中的字符a都变成字符b,并创建新的字符串<br> 3.<strong>字符串的切片(截取)</strong><br> 切片slice操作可以快速提取子字符串,标准格式为[起始偏移量start:终止偏移量end:步长step]<br> start若未声明,默认是字符串起点开始<br> end若未声明,默认是字符串末尾结束<br> step若未声明,默认是1。若为负数,则为反向提取<br> start:end 包头不包尾<br> start和end不在【0,len()】范围内也不会报错,end&#x3D;-1 start&#x3D;0<br>4.<strong>字符串的分割</strong><br>split()可以基于指定分隔符将字符串分割成多个子字符串(存储到列表中)。如果不指定分隔符,则默认使用空白字符(换行符&#x2F;空格&#x2F;制表符)<br>a.split(‘b’)其中字符b为指定分隔符,a为被处理字符串.</p><p>5.<strong>字符串的判断</strong><br>in&#x2F;not in 关键字 可以判断某个字符(子字符串)是某存在于字符串中</p><p>6.<strong>字符串的查找</strong><br>a.startswith(‘b’)确定是否是以指定字符串开头<br>a.endswith(‘b’)确定是否是以指定字符串结尾<br>a.find(‘b’)第一次出现指定字符的索引<br>a.rfind(‘b’)最后一次出现指定字符串的索引<br>a.count(‘b’)指定字符串出现了几次<br>a.isalnum()所有字符是否全是字母或是数字</p><p>7.<strong>字符串的首尾删除</strong><br>可以通过strip()去除字符串首尾指定信息。通过lstrip可以去除字符串左边指定信息,rstrip可以去除字符串右边指定信息。<br>‘str’.strip(“b”)删除str两侧所有的b字符</p><p>8.<strong>字符串的大小写转换</strong><br>a.capitalize()产生新的字符串,首字母大写<br>a.tltle()产生新的字符串,每个单词都首字母大写<br>a.upper()产生新的字符串,所有字符全转成大写<br>a.lower()产生新字符串,所有字符全转成小写<br>a.swapcase()产生新的字符串,所有字母大小写转换</p><p>9.<strong>字符串的格式排版</strong></p><p>a.center(num,”b”) num是排版之后字符串的长度,b是填充字符<br>a.ljust()<br>a.rjust()</p><p>10.<strong>字符串的检测</strong><br>isalnum()是否全为字母或数字<br>isalpha()是否全为字母组成(含汉字)<br>isdigit()是否全是数字<br>isspace()是否全为空白符<br>isupper()是否为大写字母<br>islower()是否为小写字母</p><h4 id="1-1-10-字符串的地址"><a href="#1-1-10-字符串的地址" class="headerlink" title="1.1.10 字符串的地址"></a>1.1.10 字符串的地址</h4><p>1.<strong>字符串驻留机制</strong><br>仅保存一份相同且不可变字符串的方法,不同的值被存放在字符串驻留池中。Python支持字符串驻留机制,对于符合标识符规则的字符串(仅包含_,字母,数字)会启用字符串驻留机制。<br>即当两个字符串的value相同且符合标识符规则,则两个字符串的地址相同。<br>若涉及到不符合标识符规则的符号,两个字符串的地址还是会不同。<br>2.<strong>地址的获取</strong><br>id()<br>3.<strong>地址的判断</strong><br>is&#x2F;not is 可以判断两个对象是否是同一个对象,比较的是对象的地址。</p><h4 id="1-1-11-字符串的比较"><a href="#1-1-11-字符串的比较" class="headerlink" title="1.1.11 字符串的比较"></a>1.1.11 字符串的比较</h4><p>利用&#x3D;&#x3D;,!&#x3D;可以判断两个字符串是否含有相同字符。</p><h4 id="1-1-12-字符串的格式化"><a href="#1-1-12-字符串的格式化" class="headerlink" title="1.1.12 字符串的格式化"></a>1.1.12 字符串的格式化</h4><p>利用format()实现字符串的格式化<br>str.format()<br>1.<strong>利用索引</strong><br>b &#x3D; “{0},{1},{0}”<br>b.format(“a”,”b”)<br>b &#x3D; “a,b,a”<br>2.<strong>利用参数名</strong><br>c &#x3D; “名字是{name},年龄是{age}”<br>c.format(age&#x3D;19,name&#x3D;’xzp’)</p><p>3.<strong>在格式化中使用填充与对齐</strong><br>“我是{0},我喜欢{1:&lt;8}”.format(“xzp”,”ctf”)<br>^、&lt;、&gt;分别是居中,左对齐,右对齐,不指定默认是右对齐<br>:后面带的是填充字符,只能是一个字符,不指定的话默认是空格</p><p>4.<strong>数字格式化</strong><br>浮点数通过f,整数通过d进行需要的格式化<br>a &#x3D; “我是{0},我的存款有{1:.2f}”<br>a.format(“xzp”,28888,23412)<br>输出:”我是xzp,我有存款28888.23”</p><h4 id="1-1-13-可变字符串"><a href="#1-1-13-可变字符串" class="headerlink" title="1.1.13 可变字符串"></a>1.1.13 可变字符串</h4><p>在Python中,字符串属于不可变对象,不支持原地修改,如果需要修改其中的值,只能创建新的字符串。不过可以使用io.StringIO对象或者array模块,原地修改字符串<br>import io<br>s &#x3D; “hello,xzp”<br>sio&#x3D;io.StringIO(s)<br>sio.getvalue()获取字符串的值<br>“hello.xzp”<br>sio.seek(7)到达修改位置<br>sio.write(“g”)修改<br>sio.getvalue()<br>“hello,gzp”</p><h2 id="1-2-列表"><a href="#1-2-列表" class="headerlink" title="1.2 列表"></a>1.2 列表</h2><p>列表是一种数据存储方式,用来存储一系列的数据,在内存中,列表就是一块用来存放多个值的连续的内存空间。列表中存储的是对象的地址。<br>列表是用于存储任意数目,任意类型数据集合。<br>列表是内置可变序列,是包含多个元素的有序连续的内存空间。python的列表大小可变。<br>字符串和列表都是序列类型,字符串是字符序列,列表是任何元素的序列,所以字符串的方法,列表中也有类似的。</p><h3 id="1-2-1-列表的创建"><a href="#1-2-1-列表的创建" class="headerlink" title="1.2.1 列表的创建"></a>1.2.1 列表的创建</h3><p>1.<strong>基本语法[]的创建</strong><br>a &#x3D;[] #创建一个空的列表对象</p><p>2.<strong>list()创建</strong><br>使用list()可以将任何可迭代的数据转化成列表<br>a &#x3D; list()   #创建一个空的列表对象</p><p>3.<strong>range()创建整数列表</strong><br>range(start,end,step)<br>start可选,默认是0<br>end必选 表示结尾数字<br>step可选,表示步长,默认是1<br>a &#x3D; list(range(10))<br>[0,1,2,3,4,5,6,7,8,9]</p><p>4.<strong>推导式生成列表</strong><br>使用列表推导式可以非常方便的创建列表,在开发中经常使用。<br>a &#x3D; [x*2 for x in range(5) if x%5 &#x3D;&#x3D;0]<br>*循环创建多个语句<br>通过if过滤元素</p><h3 id="1-2-2-列表元素的增加和删除"><a href="#1-2-2-列表元素的增加和删除" class="headerlink" title="1.2.2 列表元素的增加和删除"></a>1.2.2 列表元素的增加和删除</h3><p>当列表增加和删除元素时,列表会自动进行内存管理,大大减少了程序员的负担。但这个特点涉及列表元素的大量移动,效率较低。除非必要,一般只在列表的尾部添加或者删除元素,这会大大提高列表的操作效率。<br>1.<strong>append()</strong><br>原地修改列表对象,是真正的列表尾部添加新的元素,速度最快,推荐使用。<br>a &#x3D; [20,40]<br>a.append(80)<br>a &#x3D; [20,40,80]<br>2.<strong>+运算符操作</strong><br>并不是真正的尾部添加元素,而是创建新的列表对象,将原列表的元素和新列表的元素依次复制到新的列表对象中。这样,会涉及大量的复制操作,对于操作大量元素不建议使用。<br>a &#x3D; a + [80]<br>a &#x3D; [20,40,80]<br>3.<strong>extend()方法</strong><br>将目标列表的所有元素添加到本列表的尾部,属于原地操作,不创建新的列表对象。<br>a &#x3D; [20,40]<br>a.extend([50,60])<br>a &#x3D; [20,40,50,60]<br>4.<strong>insert()元素</strong><br>使用insert()方法将指定的元素插入到列表对象的任意指定位置,这样会让插入位置后面所有的元素进行移动,会影响处理速度。涉及大量元素时,尽量避免使用。<br>a.insert(b,c)b是索引位置,c是待添加的元素。<br>类似这种移动的函数还有remove(),pop(),del()<br>5.<strong>乘法扩展</strong><br>使用乘法扩展列表,回升一个新列表,新列表元素时原列表<br>元素的多次重复。<br>适用于乘法操作的还有:字符串、元组。<br>6.<strong>列表元素的删除</strong><br>6.1 <strong>del删除</strong><br>删除列表指定位置的元素<br>del a[b] a是列表 b是索引位置<br>6.2 <strong>pop()方法</strong><br>pop删除并返回指定位置元素,如果未指定位置,默认操作列表最后一个元素<br>a.pop(1) 1是索引位置<br>a &#x3D; [10,20,30,40]<br>得到结果 20<br>6.3 <strong>remove()方法</strong><br>删除首次出现的指定元素,若不存在该元素抛出异常</p><h3 id="1-2-3-列表元素访问和计数"><a href="#1-2-3-列表元素访问和计数" class="headerlink" title="1.2.3 列表元素访问和计数"></a>1.2.3 列表元素访问和计数</h3><p>1.<strong>通过索引直接访问元素</strong><br>a[b] b是索引位置<br>2.<strong>index()获得指定元素在列表中首次出现的索引</strong><br>index()可以获取指定元素首次出现的索引位置。语法是index(value,start,end)其中,start和end指定了搜索的范围。value是指定元素。end默认是最后<br>3.<strong>count()获得指定元素在列表中出现的次数</strong><br>count()可以返回指定元素在列表中出现的次数<br>a.count(b)a是列表,b是元素<br>4.<strong>列表长度</strong><br>len(a)</p><h3 id="1-2-4-成员资格判断"><a href="#1-2-4-成员资格判断" class="headerlink" title="1.2.4 成员资格判断"></a>1.2.4 成员资格判断</h3><p>1.<strong>count()</strong><br>2.<strong>in</strong></p><h3 id="1-2-5-列表的切片"><a href="#1-2-5-列表的切片" class="headerlink" title="1.2.5 列表的切片"></a>1.2.5 列表的切片</h3><p>跟前面字符串是一样的</p><h3 id="1-2-4-列表的排序"><a href="#1-2-4-列表的排序" class="headerlink" title="1.2.4 列表的排序"></a>1.2.4 列表的排序</h3><p>1.<strong>修改原列表,不建新列表的排序</strong><br>升序排列 a.sort()<br>降序排列 a.sort(reserve&#x3D;True)<br>打乱顺序 import random<br>random.shuffle(a)<br>2.<strong>建新列表的排序</strong><br>可以通过内置函数sorted()排序<br>sorted(a) a是待排序列表<br>3.<strong>reversed()返回迭代器</strong><br>内置函数reserved支持进行逆序排列,与列表对象reserve()方法不同的是reversed不对原列表做任何的修改,只是返回一个逆序排列的迭代器对象。迭代器只能使用一次(时间换空间)<br>c &#x3D; reversed(a)<br>list(c)</p><h3 id="1-2-5-列表的其他操作"><a href="#1-2-5-列表的其他操作" class="headerlink" title="1.2.5 列表的其他操作"></a>1.2.5 列表的其他操作</h3><p>1.<strong>max和min</strong><br>max&#x2F;min(a)返回列表中的最大的最小值<br>2.<strong>sum</strong><br>对数据型列表的所有元素进行求和操作</p><h3 id="1-2-6-多维列表"><a href="#1-2-6-多维列表" class="headerlink" title="1.2.6 多维列表"></a>1.2.6 多维列表</h3><p>一维列表可以帮助我们存储一维、线性的数据,二维列表就是一维列表里套一个一维列表,不断套娃形成多维列表。<br><strong>二维列表</strong><br>二维列表可以帮助我们存储二维、表格的数据。<br>索引 a[x][y]</p><h3 id="1-3-元组tuple"><a href="#1-3-元组tuple" class="headerlink" title="1.3 元组tuple"></a>1.3 元组tuple</h3><p>列表属于可变序列,可以任意修改列表中的元素。元组属于不可变序列,不能修改元组中的元素。因此,元组没有增加元素、修改元素、删除元素等方法。<br>所以,只需要学习元组的创建和删除,元素中元素访问和计数即可。元组支持如下操作:<br>1.索引访问<br>2.切片操作<br>3.连接操作<br>4.成员关系操作<br>5.比较运算操作<br>6.计数:元组长度len()、最大值max()、最小值min()、求和sum()等。<br>元组的特点:不可变序列、访问和处理速度比列表块、与整数和字符串一样,元组可以作为字典的键,列表则永远不能作为字典的键使用。</p><h4 id="1-3-1-元组的创建"><a href="#1-3-1-元组的创建" class="headerlink" title="1.3.1 元组的创建"></a>1.3.1 元组的创建</h4><p>1.<strong>通过()创建元组,小括号可以省略。</strong><br>a &#x3D; (10,20,30) or a &#x3D; 10,20,30<br>如果元组只有一个元素,则必须在后面加逗号。这是因为解释器会把(1)解释为整数1 (1,)解释成元组。<br>2.<strong>通过tuple()创建元组</strong><br>tuple(可迭代对象)<br>tuple()可以接受列表、字符串、其他序列类型、迭代器等生成元组。<br>list()可以接收元组、字符串、其他序列类型、迭代器等生成列表。<br>3.<strong>生成器推导式创建元组</strong><br>从形式上看,生成器推导式与列表推导式类似,只是生成器推导式使用小括号。列表推导式直接生成列表对象,生成器推导式生成的不是列表也不是元组,而是一个生成器对象。<br>我们可以通过生成器对象,转化成列表或者元组。也可以使用生成器对象的_next_()方法进行遍历,或者直接作为迭代器对象来使用。不管什么方式使用,元素访问结束之后,如果需要重新访问其中的元素,必须重新创建该生成器对象。<br>01:s &#x3D; (x * 2 for x in range(5))<br>s.<em>next</em>()   0<br>s.<em>next()</em>   2<br>省略号 不断取值 取到8 就没有了<br>或者还有一种方法<br> list(s) tuple(s) 利用生成器生成对应的列表或者元组</p><h4 id="1-3-2-元组的元素访问和计数"><a href="#1-3-2-元组的元素访问和计数" class="headerlink" title="1.3.2 元组的元素访问和计数"></a>1.3.2 元组的元素访问和计数</h4><p>1.<strong>元组的元素不能修改</strong><br>a &#x3D; (10,20,30)<br>a[2] &#x3D; 20会报错</p><p>2.<strong>访问与计数</strong><br>访问与计数和list是一样的,只不过返回的仍然是元组。<br>3.<strong>排序</strong><br>因为元组无法修改,所以只能生成新的列表对象。<br>内置函数sorted(tupleObj),生成新的列表对象。<br>a &#x3D; (40,20,30)<br>sorted(a)<br>得到[20,30,40]<br>4.<strong>zip</strong><br>将多个列表对应位置的元素组成元组,并返回这个zip对象</p><h3 id="1-4-字典"><a href="#1-4-字典" class="headerlink" title="1.4 字典"></a>1.4 字典</h3><p>字典是“键值对”的无序可变序列,字典中的每个元素都是一个“键值对”,包含:“键对象”和“值对象”。可以通过“键对象”实现快速获取、删除、更新对应的“值对象”。<br>列表中我们通过“下标数字”找到对应的对象。字典中通过“键对象”找到对应的“值对象”。键是任意的不可变数据。比如:整数,浮点数,字符串,元组。但是:列表、字典、集合这些可变对象,不能作为键。并且键不可重复。<br>值可以是任意的数据,并且可重复。</p><h4 id="1-4-1-字典的创建"><a href="#1-4-1-字典的创建" class="headerlink" title="1.4.1 字典的创建"></a>1.4.1 字典的创建</h4><p>1.<strong>通过“{ }”、dict()创建字典对象</strong><br>a &#x3D; (‘name’:’xzp’,’age’:18)<br>a &#x3D; dict(name&#x3D;’age’,age&#x3D;18)<br>a &#x3D; dict([(‘name’,’xzp’),(‘age’,18)])<br>2.<strong>通过zip()创建字典对象</strong><br>k &#x3D; [‘name’,’age’,’job’]<br>v &#x3D; [‘xzp’,18.’stu’]<br>d &#x3D; dict(zip(k,v))注意这边的参数前后顺序<br>d  {‘name’:’xzp’,’age’&#x3D;18,’job’&#x3D;’stu’}<br>3.<strong>通过fromkeys创建值为空的字典</strong><br>a &#x3D; dict.fromkeys([‘name’,’age’,’job’])<br>生成a {‘name’:None,’age’:None,’job’:None}</p><h4 id="1-4-2-字典元素的访问"><a href="#1-4-2-字典元素的访问" class="headerlink" title="1.4.2 字典元素的访问"></a>1.4.2 字典元素的访问</h4><p>1.<strong>通过[key]获得value。若key不存在,抛出异常。</strong><br>a[key]  a是字典<br>2.<strong>通过get()方法</strong><br>a.get(key) a是字典 若不存在 返回None<br>a.get(key,b) 若不存在 返回b<br>3.<strong>列出所有的键值对</strong><br>a.items()<br>4.<strong>列出所有的键,值</strong><br>a.keys()<br>a.values()<br>5.<strong>键值对的个数</strong><br>len()<br>6.<strong>检测一个键是否在字典中</strong><br>a in b<br>a是键 b是字典 使用in操作符</p><h4 id="1-4-3-字典元素添加、修改、删除"><a href="#1-4-3-字典元素添加、修改、删除" class="headerlink" title="1.4.3 字典元素添加、修改、删除"></a>1.4.3 字典元素添加、修改、删除</h4><p>1.<strong>给字典添加键值对</strong><br>如果key已经存在,则覆盖旧的键值对;如果key不存在,则新增键值对。<br>a[x]&#x3D;y   x是key y是value<br>2.<strong>update()</strong><br>将新字典中所有键值对全部添加到旧字典对象上。如果key有重复,则直接覆盖。<br>a.update(b)<br>a是旧的 b是新的<br>3.<strong>字典中元素的删除</strong><br>1.del(a[key])删除一个键值对<br>2.clear()删除所有键值对<br>3.pop()删除指定键值对,并返回对应的value<br>a.pop(key)  得到value<br>4.<strong>popitem()</strong><br>随机删除和返回该键值对。字典是无序可变序列,因此没有第一个元素、最后一个元素的概念;popitem弹出随机的项,因为字典并没有最后的元素或者其他有关顺序的概念,若想一个接一个地移除并处理项,这个方法就非常有效(因为不用首先获取键地列表)</p><h4 id="1-4-4-序列解包"><a href="#1-4-4-序列解包" class="headerlink" title="1.4.4 序列解包"></a>1.4.4 序列解包</h4><p>序列解包可以用于元组,列表,字典。学列解包可以对多个变量赋值。x,y,z&#x3D;(10,20,30)<br>序列解包用于字典时,默认是对key进行操作;如果需要对键值对操作,则需要使用items();如果需要对key操作,则需要使用values()操作</p><h2 id="第二部分-基础算法"><a href="#第二部分-基础算法" class="headerlink" title="第二部分 基础算法"></a>第二部分 基础算法</h2><h3 id="2-1-基本运算符"><a href="#2-1-基本运算符" class="headerlink" title="2.1 基本运算符"></a>2.1 基本运算符</h3><ul><li>加法</li></ul><ul><li>减法</li></ul><ul><li>乘法<br>&#x2F; 浮点数除法 8&#x2F;2 &#x3D;&#x3D; 4.0<br>&#x2F;&#x2F; 整数除法 7&#x2F;&#x2F;2 &#x3D;&#x3D; 2<br>%模(取余)7%4 &#x3D;&#x3D; 3</li></ul><p>** 幂<br>and or not 与 或 非<br>is,is not 同一性判断<br>&lt;,&lt;&#x3D;,&gt;,&gt;&#x3D;,!&#x3D;,&#x3D;&#x3D; 比较值之间的关系,可以连用<br>|, ^,&amp; 按位或,按位异或,按或与<br>&lt;&lt;,&gt;&gt;移位</p><h3 id="2-2-控制语句"><a href="#2-2-控制语句" class="headerlink" title="2.2 控制语句"></a>2.2 控制语句</h3>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
